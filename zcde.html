<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>bluesky social network analysis pipeline</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="zcde_files/libs/clipboard/clipboard.min.js"></script>
<script src="zcde_files/libs/quarto-html/quarto.js"></script>
<script src="zcde_files/libs/quarto-html/popper.min.js"></script>
<script src="zcde_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="zcde_files/libs/quarto-html/anchor.min.js"></script>
<link href="zcde_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="zcde_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="zcde_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="zcde_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="zcde_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="README.md"><i class="bi bi-file-code"></i>Github (GFM)</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><code>bluesky</code> social network analysis pipeline</h1>
<p class="subtitle lead">Use case for digital disease detection</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Social media platforms have increasingly become valuable sources of real-time information, reflecting public sentiment and behavior. This project explores the potential of Bluesky, a relatively new social media platform, for digital disease detection (DDD), specifically focusing on influenza-like illness (ILI). By building an end-to-end data pipeline to collect, process, and analyze Bluesky data in conjunction with traditional epidemiological data sources from organizations like the WHO and CDC, this project aims to assess the feasibility and effectiveness of using Bluesky as an early warning system for disease outbreaks.</p>
<p>This is combined project for the 2025 Data Engineering Zoomcamp and my course in Digital Epidemiology at Hasselt University.</p>
<p>The idea is to extract an epidemiological signal from social media posts by counting posts matching queries related to ILI and correlate them with public health surveillance data. Similar studies have been performed using data from <code>twitter</code> who yielded promising results. For obvious reasons, this kind of study is not feasible anymore and <code>blueksy</code> is a potential alternative.</p>
<section id="pipeline-schema" class="level1">
<h1>Pipeline schema</h1>
<p><img src="./zcde_docs/img/pipeline_graph.jpeg" class="img-fluid"></p>
</section>
<section id="tools" class="level1">
<h1>Tools</h1>
</section>
<section id="data-sources" class="level1">
<h1>Data Sources</h1>
<ul>
<li><p><strong>Bluesky API</strong>: This provides real-time access to posts and user data on the Bluesky platform.</p></li>
<li><p><strong>WHO Data</strong>: Data from the World Health Organization (WHO) serves as a crucial epidemiological reference, offering reliable statistics on influenza and other diseases, but there are delays in publication.</p></li>
<li><p><strong>CDC Data</strong>: Similar to the WHO, the Centers for Disease Control and Prevention (CDC) provides valuable data on disease prevalence and trends in the United States, but the dataset granularity is weekly. Up to December 2024 the data from the CDC were also incorporated into the WHO data but the data transmission to the WHO was stopped by the Trump administration.</p></li>
</ul>
</section>
<section id="data-ingestion" class="level1">
<h1>Data ingestion</h1>
<p>The data extraction and ingestion to the BigQuery staging area (data lake if you will) uses out-of-the-box functionality of <code>dlt</code> especially denormalization of the <code>json</code> data for <code>bluesky</code> posts.</p>
<p>Each pipeline is instantiated using the <code>dlt init &lt;source&gt; &lt;destination&gt;</code>, which creates the <code>.dlt/</code> directory containing the necessary configuration files.</p>
<p>Credentials necessary to run the pipeline are stored in <code>.dlt/secrets.toml</code> which are used for testing and locally initiated runs of the pipeline.</p>
<p>In production, credentials are read from environment variables, see the paragraph on <a href="#secrets-and-credentials-handling">workflow orchestration</a>.</p>
<section id="bluesky-api" class="level2">
<h2 class="anchored" data-anchor-id="bluesky-api">Bluesky API</h2>
<p>Two <code>dlt</code> pipelines were built using the <a href="http://public.api.bsky.app/"><code>bluesky</code> API</a>.</p>
<section id="bluesky-posts" class="level3">
<h3 class="anchored" data-anchor-id="bluesky-posts"><code>bluesky</code> posts</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Usage:</span> bsky_post_pipeline.py QUERY START_DATE <span class="op">&lt;</span>flags<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">optional</span> flags:        <span class="at">--end_date</span> <span class="kw">|</span> <span class="ex">--out_file</span> <span class="kw">|</span> <span class="ex">--n_jobs</span> <span class="kw">|</span> <span class="ex">--verbose</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This pipeline retrieves posts matching a given search query on a given date or during a specified time window. It runs in parallel using at max. 50 connections/threads. The retrieved posts are transferred to BigQuery by <code>dlt</code>, each query has its own table.</p>
</section>
<section id="bluesky-post-counts" class="level3">
<h3 class="anchored" data-anchor-id="bluesky-post-counts"><code>bluesky</code> post counts</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Usage:</span> bsky_housekeeping_pipeline.py QUERY START_DATE <span class="op">&lt;</span>flags<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">optional</span> flags:        <span class="at">--end_date</span> <span class="kw">|</span> <span class="ex">--out_file</span> <span class="kw">|</span> <span class="ex">--n_jobs</span> <span class="kw">|</span> <span class="ex">--verbose</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This pipeline is very similar to the <code>bsky_posts</code> pipeline. It is named <code>housekeeping</code> as it retrieves only aggregated post counts per query per date which serves as an indicator for overall user activity on <code>bluesky</code>.</p>
</section>
</section>
<section id="who-data" class="level2">
<h2 class="anchored" data-anchor-id="who-data">WHO Data</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Usage:</span> who_ili_pipeline.py <span class="st">"{fluid | flunet}"</span> <span class="op">&lt;</span>flags<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">optional</span> flags:        <span class="at">--verbose</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Case data from the WHO are available in two datasets: <code>FluID</code> and <code>FluNet</code> which are made available in <code>.csv</code> files. <code>pandas</code> is used to load these files and <code>dlt</code> transfers them to a table in BigQuery.</p>
</section>
<section id="cdc-data-rki-data" class="level2">
<h2 class="anchored" data-anchor-id="cdc-data-rki-data">CDC Data, RKI Data</h2>
<p>Similar pipelines are implemented for data from the Centers for Disease Control and Prevention (CDC) and the Robert-Koch-Institute (RKI), the public health agencies of the USA and Germany, respectively. These pipelines are not used in the current project but might be in the future.</p>
</section>
</section>
<section id="data-transformation" class="level1">
<h1>Data Transformation</h1>
<p>Data transformation from the BigQuery staging area to the BigQuery data warehouse is accomplished using <code>dbt</code>. There is some complexity in aligning the time series of post counts from <code>bluesky</code> (daily data) to the public health data which is available aggregated by week.</p>
<p>The figure shows as an example of combining WHO surveillance data with <code>bluesky</code> post counts in German.</p>
<p><img src="./zcde_docs/img/dbt_lineage_de.png" class="img-fluid"></p>
</section>
<section id="time-series-forecasting" class="level1">
<h1>Time Series forecasting</h1>
</section>
<section id="cicd" class="level1">
<h1>CI/CD</h1>
</section>
<section id="workflow-automation-with-kestra" class="level1">
<h1>Workflow automation with <code>kestra</code></h1>
<p>The pipeline is orchestrated using <code>kestra</code>. Basically, there is one flow defined for each extraction pipeline, building all the tables using <code>dbt</code> and fitting the machine learning models. (see <a href="./orchestration/kestra/flows/">flows</a>).</p>
<p>All flows are chained together in a <a href="./orchestration/kestra/flows/bsky_main_triggered.yml">main flow</a> which is triggered each night to ingest and process the data of the preceeding day.</p>
<section id="secrets-and-credentials-handling" class="level2">
<h2 class="anchored" data-anchor-id="secrets-and-credentials-handling">Secrets and credentials handling</h2>
<p>In the open-source version of <code>kestra</code>, secrets are handled via environement variables that need to be <code>base64</code> encoded, prefixed with <code>SECRET_</code> and passed to the the docker container on startup. I created a python commandline tool that abstracts some of the complexity : <a href="https://github.com/kantundpeterpan/kestra_secret_encoder"><code>kestra_secret_encoder</code></a>.</p>
<section id="dlt" class="level3">
<h3 class="anchored" data-anchor-id="dlt"><code>dlt</code></h3>
<p>When <code>dlt</code> does not find a <code>secrets.toml</code> file, it looks for credentials in using specifically named environment variables. For BigQuery:</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>[./orchestration/kestra/flows/bsky_housekeeping.yml](./orchestration/kestra/flows/bsky_housekeeping.yml)</strong></pre>
</div>
<div class="sourceCode" id="cb4" data-filename="[./orchestration/kestra/flows/bsky_housekeeping.yml](./orchestration/kestra/flows/bsky_housekeeping.yml)"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">env</span><span class="kw">:</span><span class="at">      </span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">DESTINATION__BIGQUERY__CREDENTIALS__PROJECT_ID</span><span class="kw">:</span><span class="at"> </span><span class="st">"{{ secret('BIGQUERY_PROJECT_ID') }}"</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">DESTINATION__BIGQUERY__CREDENTIALS__PRIVATE_KEY</span><span class="kw">:</span><span class="at"> </span><span class="st">"{{ secret('BIGQUERY_PRIVATE_KEY') }}"</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">DESTINATION__BIGQUERY__CREDENTIALS__CLIENT_EMAIL</span><span class="kw">:</span><span class="at"> </span><span class="st">"{{ secret('BIGQUERY_CLIENT_EMAIL') }}"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>(taken from <a href="./orchestration/kestra/flows/bsky_housekeeping.yml">./orchestration/kestra/flows/bsky_housekeeping.yml</a>)</p>
</section>
<section id="dbt" class="level3">
<h3 class="anchored" data-anchor-id="dbt"><code>dbt</code></h3>
<p>For the production runs of <code>dbt</code> a special <a href="./dbt/digepi_bsky/docker_config/profiles.yml"><code>docker_config/profiles.yml</code></a> is used with</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dbt</span> build <span class="at">--profiles-dir</span> ./docker_config</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>during the runs.</p>
<p>It reads the credentials from environment variables:</p>
<p><code>yaml docker_config/profiles.yaml ... keyfile_json:         type: service_account         project_id: digepizcde         private_key: "{{ env_var('DBT_BIGQUERY_PRIVATE_KEY') }}"         client_email: "{{ env_var('DBT_BIGQUERY_CLIENT_EMAIL') }}"         private_key_id: "{{ env_var('DBT_BIGQUERY_PRIVATE_KEY_ID') }}"         client_email: "{{ env_var('DBT_BIGQUERY_CLIENT_EMAIL') }}" ...</code></p>
</section>
</section>
<section id="flow-organizations" class="level2">
<h2 class="anchored" data-anchor-id="flow-organizations">Flow organizations</h2>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>